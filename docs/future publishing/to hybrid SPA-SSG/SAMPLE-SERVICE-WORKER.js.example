/**
 * Service Worker for Comic Reader SPA
 *
 * Caching strategy:
 * - Reader shell: Cache first, update in background
 * - Manifests: Stale-while-revalidate (serve cached, fetch fresh)
 * - Comic images: Cache first (immutable)
 *
 * The SPA reads only from its own origin - it never contacts the CMS.
 * This service worker enables offline reading and instant page transitions.
 */

const CACHE_VERSION = 'v1'
const SHELL_CACHE = `reader-shell-${CACHE_VERSION}`
const MANIFEST_CACHE = `manifests-${CACHE_VERSION}`
const IMAGE_CACHE = `comic-images-${CACHE_VERSION}`

// Reader shell files (update CACHE_VERSION to bust cache)
const SHELL_FILES = [
  '/reader/',
  '/reader/index.html',
  '/reader/reader.js',
  '/reader/reader.css',
]

// ---
// Installation
// ---

self.addEventListener('install', (event) => {
  console.log('[SW] Installing')

  event.waitUntil(
    caches.open(SHELL_CACHE).then((cache) => {
      return cache.addAll(SHELL_FILES)
    })
  )

  self.skipWaiting()
})

// ---
// Activation
// ---

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating')

  // Clean up old caches
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => {
            const isOldVersion = (
              name.startsWith('reader-shell-') ||
              name.startsWith('manifests-') ||
              name.startsWith('comic-images-')
            ) && !name.endsWith(CACHE_VERSION)
            return isOldVersion
          })
          .map((name) => caches.delete(name))
      )
    })
  )

  self.clients.claim()
})

// ---
// Fetch Handling
// ---

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url)

  // Only handle GET requests from same origin
  if (event.request.method !== 'GET') return
  if (url.origin !== self.location.origin) return

  // Route to appropriate strategy
  if (isShellRequest(url)) {
    event.respondWith(cacheFirst(event.request, SHELL_CACHE))
  } else if (isManifestRequest(url)) {
    event.respondWith(staleWhileRevalidate(event.request, MANIFEST_CACHE))
  } else if (isImageRequest(url)) {
    event.respondWith(cacheFirst(event.request, IMAGE_CACHE))
  }
})

function isShellRequest(url) {
  return url.pathname.startsWith('/reader')
}

function isManifestRequest(url) {
  return url.pathname.startsWith('/sites/') && url.pathname.endsWith('.json')
}

function isImageRequest(url) {
  return url.pathname.startsWith('/media/') ||
    /\.(jpg|jpeg|png|gif|webp)$/i.test(url.pathname)
}

// ---
// Caching Strategies
// ---

/**
 * Cache First: Return cached, fetch only if not cached
 */
async function cacheFirst(request, cacheName) {
  const cached = await caches.match(request)
  if (cached) return cached

  try {
    const response = await fetch(request)
    if (response.ok) {
      const cache = await caches.open(cacheName)
      cache.put(request, response.clone())
    }
    return response
  } catch (error) {
    return new Response('Offline', { status: 503 })
  }
}

/**
 * Stale While Revalidate: Return cached immediately, fetch fresh in background
 */
async function staleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName)
  const cached = await cache.match(request)

  const fetchPromise = fetch(request).then((response) => {
    if (response.ok) {
      cache.put(request, response.clone())
      // Check for updates
      if (cached) {
        checkForManifestUpdate(request.url, cached, response.clone())
      }
    }
    return response
  }).catch(() => null)

  return cached || fetchPromise
}

// ---
// Update Detection
// ---

async function checkForManifestUpdate(url, oldResponse, newResponse) {
  try {
    const oldData = await oldResponse.json()
    const newData = await newResponse.json()

    // Check if page count increased (for comic manifests)
    if (newData.navigation?.totalPages > oldData.navigation?.totalPages) {
      const newCount = newData.navigation.totalPages - oldData.navigation.totalPages
      notifyClients({
        type: 'NEW_PAGES',
        comic: newData.comic?.slug,
        count: newCount,
        message: `${newCount} new page${newCount > 1 ? 's' : ''} available`,
      })
    }

    // Check if comics index changed
    if (url.endsWith('comics.json') && newData.comics?.length > oldData.comics?.length) {
      notifyClients({
        type: 'NEW_COMICS',
        message: 'New comics available',
      })
    }
  } catch (e) {
    // Ignore parse errors
  }
}

async function notifyClients(message) {
  const clients = await self.clients.matchAll({ type: 'window' })
  clients.forEach((client) => client.postMessage(message))
}

// ---
// Prefetch API (called from reader)
// ---

self.addEventListener('message', (event) => {
  if (event.data.type === 'PREFETCH') {
    prefetchUrls(event.data.urls)
  }

  if (event.data.type === 'CLEAR_IMAGES') {
    caches.delete(IMAGE_CACHE)
  }
})

async function prefetchUrls(urls) {
  const cache = await caches.open(IMAGE_CACHE)

  for (const url of urls) {
    const cached = await cache.match(url)
    if (cached) continue

    try {
      const response = await fetch(url)
      if (response.ok) {
        await cache.put(url, response)
      }
    } catch (e) {
      // Ignore prefetch failures
    }
  }
}


// ---
// Usage from Reader:
//
// // Register service worker
// if ('serviceWorker' in navigator) {
//   navigator.serviceWorker.register('/reader/sw.js')
// }
//
// // Listen for updates
// navigator.serviceWorker.addEventListener('message', (event) => {
//   if (event.data.type === 'NEW_PAGES') {
//     showToast(event.data.message)
//   }
// })
//
// // Prefetch upcoming pages
// navigator.serviceWorker.controller?.postMessage({
//   type: 'PREFETCH',
//   urls: ['/media/page5.jpg', '/media/page6.jpg', '/media/page7.jpg']
// })
// ---
